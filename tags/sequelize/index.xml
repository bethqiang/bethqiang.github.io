<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sequelize on Beth Qiang</title>
    <link>http://bethqiang.com/tags/sequelize/index.xml</link>
    <description>Recent content in Sequelize on Beth Qiang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://bethqiang.com/tags/sequelize/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Week 3, Days 2 and 3: On Feeling Completely Overwhelmed</title>
      <link>http://bethqiang.com/blog/2016/11/16/on-feeling-completely-overwhelmed/</link>
      <pubDate>Wed, 16 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://bethqiang.com/blog/2016/11/16/on-feeling-completely-overwhelmed/</guid>
      <description>

&lt;p&gt;Let’s talk about feelings for a second. I’m generally a very optimistic person with a decent amount of confidence in myself, my critical-thinking and problem-solving abilities, and my ability to stick with something when it’s challenging. I don’t like to dwell on the negatives, and I generally try not to let myself get too down.&lt;/p&gt;

&lt;p&gt;But today was kind of a sucky day. It didn’t start off that way. I woke up after six hours of sleep feeling a little sleepy, but feeling pretty good about most of the material we had covered in the past couple of days. I knew that my blog post from yesterday needed editing, and set out to do that before class.&lt;/p&gt;

&lt;p&gt;As I was editing, I realized that maybe I didn’t understand some of the things we did as much as I thought I did. My post didn’t really make sense in a lot of places, and I couldn’t figure out how to &lt;em&gt;make&lt;/em&gt; it make sense. Then, we reviewed the solution to the workshop we did yesterday, and I quickly started getting overwhelmed – I knew generally how to write decent tests, and I thought I had a pretty good grasp of promises, but I was having a really hard time seeing how everything was connecting.&lt;/p&gt;

&lt;p&gt;Then, we talked more in-depth about promises, and my brain was still a little boggled and twisted from the session before, and I wasn’t able to follow as much as I maybe could have otherwise. By the end of the morning, I was completely overwhelmed, stressed, and my confidence was at the lowest point it’s been since Fullstack began. My brain was running in circles around itself, and even things I knew that I knew started to not make any sense.&lt;/p&gt;

&lt;p&gt;During lunch, when I usually take some time to read programming blogs or review what we covered during the morning or a variety of related things, my sole goal was to get out of the house and do something unrelated to coding for the entire hour and a half. I took a 45 minute walk while listening to a new podcast by Stephen Dubner, of Freaknomics fame, called &lt;a href=&#34;http://freakonomics.com/tmsidk/&#34; target=&#34;_blank&#34;&gt;Tell Me Something I Don’t Know&lt;/a&gt;. (It was literally a podcast about random facts. It was pretty interesting, though I don’t know if I’ll be a regular listener.) I then ate lunch, watched some cute puppy videos, and read about politics.&lt;/p&gt;

&lt;p&gt;Once I had an opportunity to calm down and reassure myself that I did in fact, know how to code and solve problems with some degree of competency, and that yes, I could do this, I knew I needed to change something. I needed more time. Time for me to do thorough concept reviews in the evenings, and do fun Code Wars problems, and go to meetups, and work on personal projects, and do more functional programming because for some reason that really excites me. I needed time do things that I find fun that aren&amp;rsquo;t directly related to class. And also, you know, sleep. But more importantly, I &lt;em&gt;also&lt;/em&gt; needed some time every day to do things like go for 45 minute walks or watch cute puppy videos or get dinner with a friend once in a blue moon. And run. Running helps. (That&amp;rsquo;s a long list, I know.)&lt;/p&gt;

&lt;p&gt;This isn&amp;rsquo;t an uncommon theme; I mentioned that I needed to improve upon my time management and prioritization in &lt;a href=&#34;http://bethqiang.com/blog/2016/11/13/fullstack-academy-week-2/&#34; target=&#34;_blank&#34;&gt;last week&amp;rsquo;s reflection post&lt;/a&gt;. I knew, at the time of writing that, that I needed to change &lt;em&gt;something&lt;/em&gt;. But I didn&amp;rsquo;t realize that I couldn&amp;rsquo;t keep doing what I was doing, and still stay sane.&lt;/p&gt;

&lt;p&gt;Outside of class and evening reviewing (which, in and of itself, I need to find a way to optimze), writing these posts have by far taken the largest chunk of my time. Daily 1,500-word blog posts are great, and I’m sure I’ll thank myself for them later. But, I’m starting to realize with the schedule that we have and the time I need outside of class, they’re unsustainable. Frankly, they take too much time to write, and even just saving an hour a day will give me an hour to start doing other things. That definitely doesn&amp;rsquo;t mean I&amp;rsquo;m going to abandon writing about each day. I just have to choose more wisely what I want to write, and cap the length of and detail in each post, thereby lessening the time that they take.&lt;/p&gt;

&lt;p&gt;In the interest of keeping some kind of record of what we’ve been doing and learning the past two days, here’s a (sort of) quick-and-dirty summary.&lt;/p&gt;

&lt;h2 id=&#34;back-end-testing-and-sequelize-magic&#34;&gt;Back-End Testing and Sequelize Magic&lt;/h2&gt;

&lt;p&gt;We learned all about testing on the back-end. Some of the key takeaways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It’s generally preferable to use a different database to test your code than when you’re developing or when your app is in production, so that you can stick stuff in and take stuff out and completely reset your database freely. This can be done pretty easily by creating a process environment variable, and then setting a conditional for that variable when you’re setting your database.&lt;/li&gt;
&lt;li&gt;Constantly talking about Mocha and Chai made me constantly want a hot, creamy, caffeine- and sugar-laden beverages.&lt;/li&gt;
&lt;li&gt;When we’re using promises in our tests, which is often because much of what we’re testing is asynchronous, we need to include either &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;done&lt;/code&gt;. If neither are included, Mocha reads our tests, and passes them, &lt;em&gt;before our async functions finish doing what they’re supposed to do&lt;/em&gt;. And once our async functions are done, we&amp;rsquo;ll get an error – but the tests have already passed and Mocha&amp;rsquo;s over it. So that’s not good.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Done&lt;/code&gt; is passed into our test function, and then we can invoke it at the end (and in our &lt;code&gt;catch&lt;/code&gt;) to signal to Mocha that it’s good to go and can move on to the next test. If we don’t want to use &lt;code&gt;done&lt;/code&gt;, we can use &lt;code&gt;return&lt;/code&gt; instead, and to Mocha, it’ll almost be like an implied &lt;code&gt;then&lt;/code&gt; after.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we&amp;rsquo;re creating 3 pages to test if our &lt;code&gt;findByTag&lt;/code&gt; function works, with &lt;code&gt;done&lt;/code&gt;, this would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;findByTag&#39;, function () {
  beforeEach(function(done) { // done is passed in
    Promise.all([
      Page.create({ new page info }),
      Page.create({ new page info }),
      Page.create({ new page info })
    ])
    .then(function() { // our success/error functions
      done();
    }, done)
  })
  it(&#39;gets pages with the search tag&#39;, function(done) { // done is passed in here as well
    Page.findByTag(&#39;tag&#39;)
    .then(function(pages) {
      expect(pages).to.equal(something)
      expect(pages).to.equal(somethingelse)
      done(); // this indicates the end of the async
    })
    .catch(done); // error-handling
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;return&lt;/code&gt;, the same code would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;findByTag&#39;, function () { // no done being passed
  beforeEach(function() {
    return Promise.all([ // return this
      Page.create({ info }),
      Page.create({ info }),
      Page.create({ info })
    ]) // no need for success/error functions using done
  })
  it(&#39;gets pages with the search tag&#39;, function() { // no done being passed
    return Page.findByTag(&#39;tag&#39;) // return this
    .then(function(pages) {
      expect(pages).to.equal(something)
      expect(pages).to.equal(somethingelse) // no done after this
    })
  }); // and no need for a catch(done) statement here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On Tuesday, my pair and I were working on tests for our &lt;a href=&#34;http://bethqiang.com/blog/2016/11/14/building-a-wikipedia-clone/&#34; target=&#34;_blank&#34;&gt;Wikipedia clone&lt;/a&gt;, and for one of them, we were creating an instance that pulled from two models, &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Page&lt;/code&gt;. After wrestling with it for an hour and a half and finally getting it to work the non-magical, slightly harder, and not as pretty way, our fellow then asked us if we wanted to try a little Sequelize magic to make this happen – a little something called eager creation. Here’s what we worked through to come up with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// in models &amp;gt; index.js, set associations:
Page.belongsTo(User);
User.hasMany(Page);

// in our test specs, creating a new instance:
beforeEach(function(done) {
User.create({
  name: &#39;Spock&#39;,
  email: &#39;spock@starfleet.gov&#39;,
  pages: [{
    title: &#39;Science Officer\&#39;s Log #7&#39;,
    content: &#39;Humans are emotional.&#39;,
    status: &#39;open&#39;,
    tags: [&#39;Sci-fi&#39;, &#39;TV&#39;]
    }]
    },
    {
      include: [ Page ]
    })
    .then(newInfo =&amp;gt; {
      newPageInfo = newInfo.pages; // our pages data can now be accessed via the pages property
      done();
    })
    .catch(done);
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also learned that Sequelize is way too smart and picky for its own good. For an entire hour, we tried an incredible number of ways and syntaxes to create a &lt;code&gt;page&lt;/code&gt; property, but every time, we’d get an empty array back. The fact that we got an array back showed us that Sequelize was trying to give us something, just not what we wanted. Our fellow had a sudden realization – Sequelize was looking for a &lt;code&gt;pages&lt;/code&gt; property, and we were trying to give it a &lt;code&gt;page&lt;/code&gt; property. He also told us a funny (or not, if you were him) story about how he was once trying to do something similar with a property that ended in a “y” – which, in the English language, the plural becomes “ies.” For an entire day or two, he was trying to figure out why Sequelize was putting up a fit, before realizing he had specified the plural as “ys.”&lt;/p&gt;

&lt;h2 id=&#34;promise-mechanics-and-building-a-promise-library&#34;&gt;Promise Mechanics and Building a Promise Library&lt;/h2&gt;

&lt;p&gt;Today, we spent a good deal of time talking about the mechanics of promises, and we spent the afternoon building a deferral-style promise library similar to &lt;a href=&#34;https://docs.angularjs.org/api/ng/service/$q&#34; target=&#34;_blank&#34;&gt;AngularJS’s $q service&lt;/a&gt;. We created &lt;code&gt;$Promise&lt;/code&gt; and &lt;code&gt;Deferral&lt;/code&gt; classes, with the &lt;code&gt;then&lt;/code&gt; method on the &lt;code&gt;$Promise&lt;/code&gt; prototype that took two callback functions and the &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods on the &lt;code&gt;Deferral&lt;/code&gt; prototype.&lt;/p&gt;

&lt;p&gt;The first roadblock we faced was figuring out how to trigger the &lt;code&gt;then&lt;/code&gt; and the callback functions, which was stored in the &lt;code&gt;$promise&lt;/code&gt; instance, when the promise was resolved. Our first idea was to include it in the &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; methods, but then they’d be triggered right after a promise was fulfilled – not when the &lt;code&gt;then&lt;/code&gt; was called. We ended up creating an intermediate function, whose job was solely to take the callback function off of the array it was stored in and run it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$Promise.prototype.callHandlers = function(data) {
  if (this._state !== &#39;pending&#39;) {
    let fn = this._handlerGroups.shift();
    // handlerGroups was an array of objects containing success and failure functions
    fn.successCb(data);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second challenge we faced was to ensure that, even if events occurred in the opposite order – if the promise is resolved after the &lt;code&gt;then&lt;/code&gt; – that the &lt;code&gt;then&lt;/code&gt; would still run. We contemplated a myriad of options, including recursion, a while loop, a &lt;code&gt;setInterval&lt;/code&gt; to check the state of the promise, and ended up going down a rabbit hole trying to research &lt;code&gt;setImmediate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We later learned that the answer was &lt;em&gt;incredibly&lt;/em&gt; easy – we could just call our &lt;code&gt;callHandlers&lt;/code&gt; function in the same function that fulfilled the promise. When the &lt;code&gt;then&lt;/code&gt; is run initially (before the promise is fulfilled), it’ll add its callback functions to the storage array, and even though it calls the &lt;code&gt;callHandlers&lt;/code&gt; method, the &lt;code&gt;callHandlers&lt;/code&gt; method won’t invoke the callback because the state is still pending. When the promise is resolved, then we just need to call the &lt;code&gt;callHandlers&lt;/code&gt; method to run the callback functions that were already stored.&lt;/p&gt;

&lt;h2 id=&#34;game-night-round-2&#34;&gt;Game Night, Round 2&lt;/h2&gt;

&lt;p&gt;We also had another Game Night, where I finally got to see some of the things my fellow classmates have been building. Someone created a pool surrounded by lava. Someone else claimed an enormous plot of land – our theory is that he&amp;rsquo;s trying to build a subdivision and drive up rent. One of our instructors decided to cover his entire plot in glass blocks (because, why not, I guess?), and the other instructor built a cute little cabin. Apparently, someone built an absolutely frightening house – I can’t tell you what that means or what it looks like, because I was too absorbed in building my treehouse to venture over there. We’re having a Minecraft hackathon on Monday afternoon, and I have very little idea of what that involves, but I’m really excited!&lt;/p&gt;

&lt;p&gt;And on another note, it&amp;rsquo;s both hilarious and not how half of this post built up into “I need to write shorter posts”&amp;hellip;and this is over 1600 words, not including the code blocks. C’mon, Beth.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Week 3, Day 1: Building a Wikipedia Clone</title>
      <link>http://bethqiang.com/blog/2016/11/14/building-a-wikipedia-clone/</link>
      <pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://bethqiang.com/blog/2016/11/14/building-a-wikipedia-clone/</guid>
      <description>&lt;p&gt;The past day has been a complete whirlwind of learning and figuring out why things are going wrong. We built a Wikipedia clone with the following features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A homepage that lists all the pages in the Wiki&lt;/li&gt;
&lt;li&gt;The ability to create new pages&lt;/li&gt;
&lt;li&gt;Page searching&lt;/li&gt;
&lt;li&gt;Tagging&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We started from the very beginning – a blank text editor, in which we required a bunch of modules, set up our middleware, enabled our Nunjucks rendering engine and created simple templates, and created and connected to our Postgres database.&lt;/p&gt;

&lt;p&gt;After all of the initial set up was done, we started creating our model schemas and synched them to our database. We used  &lt;a href=&#34;http://docs.sequelizejs.com/en/v3&#34; target=&#34;_blank&#34;&gt;Sequelize&lt;/a&gt; for all of our database communication. In our schemas, we had two relations: &lt;code&gt;Page&lt;/code&gt;, which contained fields like title, the URL, content, etc., and &lt;code&gt;User&lt;/code&gt;, which just contained name and email. We created validation rules – the primary ones were that most fields weren&amp;rsquo;t allowed to be null, the user email went through Sequelize&amp;rsquo;s email validation, and the status had to be open or closed and not anything else.&lt;/p&gt;

&lt;p&gt;We initially started by creating &lt;code&gt;get&lt;/code&gt; routes to &lt;code&gt;/wiki&lt;/code&gt; and &lt;code&gt;/wiki/add&lt;/code&gt;, and a &lt;code&gt;post&lt;/code&gt; route to &lt;code&gt;/wiki&lt;/code&gt; in a &lt;code&gt;wiki.js&lt;/code&gt; module in our &lt;code&gt;routes&lt;/code&gt; directory. The first, &lt;code&gt;get(&#39;/wiki&#39;)&lt;/code&gt;, would just be a list of all of the articles – a simple query to our database for all of the posts it contains. The second, &lt;code&gt;/wiki/add&lt;/code&gt;, would present the user with an HTML form to create a new article. Once a post was added, we wanted to redirect the user to the newly created page, which meant that we needed a route for our newly created page! (More on this in a second.)&lt;/p&gt;

&lt;p&gt;The last one, &lt;code&gt;post(&#39;/wiki&#39;)&lt;/code&gt;, required us to set our form with &lt;code&gt;action=&#39;/wiki/&#39;&lt;/code&gt; and &lt;code&gt;method=&#39;POST&#39;&lt;/code&gt;. When we set this up, one of the challenges that we faced was that a URL for each page couldn&amp;rsquo;t be null, but we didn&amp;rsquo;t want to create a field in the form where the user would have to manually create a URL-compatible string for it. (And you know there&amp;rsquo;s a subset of users who would do it wrong too&amp;hellip;) To address this, we set up a hook, &lt;code&gt;beforeValidate&lt;/code&gt;, in our model to transform the page&amp;rsquo;s title into a usable URL string programmatically.&lt;/p&gt;

&lt;p&gt;We used dynamic routing (&lt;code&gt;/wiki/:urlTitle&lt;/code&gt;) for each page to have its own route. One of the things we had to remember here was to keep this route above our &lt;code&gt;/wiki/add&lt;/code&gt; route, or else every time we went to the &lt;code&gt;/add&lt;/code&gt; route, our server will think that add is the &lt;code&gt;urlTitle&lt;/code&gt; and will try to send back an article called &amp;ldquo;add.&amp;rdquo; This also meant that we can&amp;rsquo;t actually have a page called &amp;ldquo;add,&amp;rdquo; but that&amp;rsquo;s a small price to pay. :)&lt;/p&gt;

&lt;p&gt;To make our lives easier and much less repetitive, we set up a virtual field called &lt;code&gt;route&lt;/code&gt;, which would add &lt;code&gt;&#39;/wiki/&#39;&lt;/code&gt; to each urlTitle to create the route that it would eventually be associated with. We created a virtual field for this because it&amp;rsquo;s always derived, so we don&amp;rsquo;t really need to store it anywhere, and we don&amp;rsquo;t want to keep having to create &lt;code&gt;res.redirect&lt;/code&gt;s in our routes, either.&lt;/p&gt;

&lt;p&gt;Now, having the ability to author a page is great. But authors probably want some credit for their contributions, right? And, we&amp;rsquo;d want to see each author&amp;rsquo;s page and the pages that they&amp;rsquo;ve written. This is where our &lt;code&gt;User&lt;/code&gt; model came in. We created a Sequelize association between our &lt;code&gt;Page&lt;/code&gt; model and our &lt;code&gt;User&lt;/code&gt; model – &lt;code&gt;Page.belongsTo(User, { as: &#39;author&#39; })&lt;/code&gt;. We later learned that this does a number of things under the hood, including changing the schema (so we had to force the schema to re-make itself) and placing instance methods on our page objects to manage the association between these two.&lt;/p&gt;

&lt;p&gt;We updated our &lt;code&gt;post&lt;/code&gt; method route with &lt;code&gt;findOrCreate&lt;/code&gt; so that if that user already existed, we&amp;rsquo;d use that user, but if it didn&amp;rsquo;t, we&amp;rsquo;d add him/her. Then, we would associate that user with the new page. This required the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  User.findOrCreate({
    where: {
      name: req.body.name,
      email: req.body.email
    }
  })
  .then(function(values) {
    const user = values[0];
    const page = Page.build({
      title: req.body.title,
      content: req.body.content
    });
    return page.save().then(function(page) {
      return page.setAuthor(user);
    };
  })
  .then(function(page) {
    res.redirect(page.route);
  })
  .catch(next);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My partner and I were &lt;em&gt;really&lt;/em&gt; confused about this for a &lt;em&gt;really&lt;/em&gt; long time. First off, we didn&amp;rsquo;t realize that Sequelize&amp;rsquo;s &lt;code&gt;belongsTo&lt;/code&gt; does a lot of things behind-the-scenes, and had no concept of the &lt;code&gt;setAuthor&lt;/code&gt; method. Second, we no idea what was going on with the nested &lt;code&gt;then&lt;/code&gt;s – why were they nested? In what order were things happening? What was being passed where? Why was everything being returned?&lt;/p&gt;

&lt;p&gt;So to tackle the first – if they weren&amp;rsquo;t nested, and more clearly defined, they would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  .then(function(values) {
    const user = values[0];
    const page = Page.build({
      title: req.body.title,
      content: req.body.content
    });
    return page.save() // resolves to a page object
  })
  .then(function(page) { // receives that page object
    return page.setAuthor(user); // &amp;lt;== ERROR: user is not defined
  };
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To help us understand what was going on, our instructor broke it down a little further:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  .then(function(values) {
    const user = values[0];
    const page = Page.build({
      title: req.body.title,
      content: req.body.content
    });
    var pageSavePromise = page.save();
    var pageSaveAndOtherStuff = pageSavePromise.then(function(page) {
      var settingAuthorPromise = page.setAuthor(user); // start setting author
      return settingAuthorPromise; // make paveSaveAndOtherStuff promise wait for this to resolve before IT resolves
    });
    return pageSaveAndOtherStuff; // this now resolves BEFORE the author setting is completed
  })
  .then(function(page) {
    return page.setAuthor(user);
  };
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;settingAuthorPromise&lt;/code&gt;, we &lt;em&gt;start&lt;/em&gt; setting the author. Then, we make the &lt;code&gt;pageSaveAndOtherStuff&lt;/code&gt; promise wait for &lt;code&gt;settingAuthorPromise&lt;/code&gt; to resolve before it resolves. But, &lt;code&gt;return pageSaveAndOtherStuff&lt;/code&gt; resolves &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; the author setting is completed.&lt;/p&gt;

&lt;p&gt;Having understood this now, instead of going with our solution-provided code, we refactored it to make it slightly more intuitive to us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  User.findOrCreate({
    where: {
      name: name,
      email: email
    }
  })
  .then(function(values) {
    const user = values[0];
    return Page.create({
      title: title,
      content: content,
      status: status,
      tags: tags
    })
    .then(function(addedPage) {
      return addedPage.setAuthor(user);
    })
  })
  .then(function(addedPage) {
    res.redirect(addedPage.route);
  })
  .catch(next);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We eliminated &lt;code&gt;page.save&lt;/code&gt; entirely by using &lt;code&gt;Page.create&lt;/code&gt; instead of &lt;code&gt;Page.build&lt;/code&gt;, and made the layout a little more linear. &lt;code&gt;Page.create&lt;/code&gt; resolves to a page object and passes it to the &lt;code&gt;page.setAuthor&lt;/code&gt; method. This takes the ID of the user and sets it as the authorId of the page. Once all of that is done, the redirect happens, and our catch clause is last.&lt;/p&gt;

&lt;p&gt;We then set up routes to &lt;code&gt;/users&lt;/code&gt; and &lt;code&gt;/users/:id&lt;/code&gt; for an individual&amp;rsquo;s page. For the later, we used a &lt;code&gt;Promise.all&lt;/code&gt; statement because we needed to do two lookups, one to the user table to get the user ID, and the second to the page table to match the &lt;code&gt;authorId&lt;/code&gt; – something that Sequelize created for us as the foreign key.&lt;/p&gt;

&lt;p&gt;Back in our wiki page route, we added in the author of each page via eager loading:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.get(&#39;/:urlTitle&#39;, function(req, res, next) {
  Page.findOne({
    where: {
      urlTitle: req.params.urlTitle
    },
    include: [
      {model: User, as: &#39;author&#39;}
    ]
  })
  .then(function(page) {
    if (page === null) {
      return next(new Error(&#39;That page was not found!&#39;));
    }
    res.render(&#39;wikipage&#39;, {
      page: page
    });
  })
  .catch(next);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which, in another feat of magic, is Sequelize&amp;rsquo;s way of basically doing a join between those two tables, and then making everything on &lt;code&gt;User&lt;/code&gt; available on &lt;code&gt;Page&lt;/code&gt; under the property &lt;code&gt;author&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last thing I ended up doing after class was setting up tags, which involved first setting a new tags field on our model (using &lt;code&gt;Sequelize.ARRAY(Sequelize.TEXT)&lt;/code&gt;), and then using &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;this.setDataValue&lt;/code&gt; to re-set the incoming tag string as an array. Then, we modified the locals object to render in our controller, and rendered the view to include our tags on each page.&lt;/p&gt;

&lt;p&gt;We also enabled the ability for the user to search for a specific tag in an HTML form with a &lt;code&gt;/search&lt;/code&gt; route. One of the mistakes I made here, was one that I mentioned above for the &lt;code&gt;/add&lt;/code&gt; route: I tried putting the &lt;code&gt;/search&lt;/code&gt; route below &lt;code&gt;/:urlTitle&lt;/code&gt;, so I was given a few error messages before I realized what was happening.&lt;/p&gt;

&lt;p&gt;We specified the search form&amp;rsquo;s method as &lt;code&gt;get&lt;/code&gt;, which meant that we had to pull data in through &lt;code&gt;req.query&lt;/code&gt; instead of &lt;code&gt;req.body&lt;/code&gt;. We created a class method on our model to &lt;code&gt;findByTag&lt;/code&gt; using the &lt;code&gt;$overlap&lt;/code&gt; operator, and used it to find all of the pages with a single tag. We also created a &lt;code&gt;findSimilar&lt;/code&gt; instance method, and added a link on each page to a list of &amp;ldquo;similar&amp;rdquo; pages (or, pages with the same tag[s] as the page that you were on).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>